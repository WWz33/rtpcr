Resistant	High	Ctrl	3	2	33.32833333	2	33.37
Resistant	High	Inoculate	1	2	32.50666667	2	33.47
Resistant	High	Inoculate	2	2	32.62333333	2	33.26
Resistant	High	Inoculate	3	2	32.565	2	33.365
Resistant	Control	Ctrl	1	2	26.89333333	2	26.91666667
Sensetive	Control	Ctrl	2	2	28.175	2	27.69
Sensetive	Control	Ctrl	3	2	27.98666667	2	27.30333333
Sensetive	Control	Inoculate	1	2	28.715	2	29.45
Sensetive	Control	Inoculate	2	2	29.01	2	29.43333333
Sensetive	Control	Inoculate	3	2	28.81333333	2	29.44166667
Sensetive	Moderate	Ctrl	1	2	30.41	2	28.73333333
Sensetive	Moderate	Ctrl	2	2	29.49666667	2	28.67333333
Sensetive	Moderate	Ctrl	3	2	29.95333333	2	28.70333333
Sensetive	Moderate	Inoculate	1	2	28.91	2	28.09666667
Sensetive	Moderate	Inoculate	2	2	28.605	2	28.64666667
Sensetive	Moderate	Inoculate	3	2	28.59	2	28.37166667
Sensetive	High	Ctrl	1	2	29.035	2	30.60333333
Sensetive	High	Ctrl	2	2	28.73	2	30.2
Sensetive	High	Ctrl	3	2	28.83166667	2	30.40166667
Sensetive	High	Inoculate	1	2	28.29666667	2	30.84
Sensetive	High	Inoculate	2	2	28.53	2	30.65
Sensetive	High	Inoculate	3	2	28.285	2	30.745
", header = T)
colnames(df)[1] <- "A"
colnames(df)[2] <- "B"
colnames(df)[3] <- "C"
colnames(df)[4] <- "rep"
colnames(df)[5] <- "Etarget"
colnames(df)[6] <- "Cttarget"
colnames(df)[7] <- "Eref"
colnames(df)[8] <- "Ctref"
df$wDCt <- (log10(df$Etarget)*df$Cttarget)-(log10(df$Eref)*df$Ctref)
# If ANOVA based on factorial design was desired:
factorialANOVA <- anova(lm0 <- lm(wDCt ~  A*B*C, df))
factorialANOVA
# If ANOVA based on completly randomized design was required: This is especially useful when you wand to do mean grouping.
df <- data.frame(df, T = paste0(df[,1],"_",df[,2],"_",df[,3]))
lm <- lm(wDCt ~ T, df)
anovaCRD <- anova(lm)
anovaCRD
#Checking normality of residuals produced by the lm object.
shapiro.test(lm$residuals)
invOrder <-function(invg){
collapsed <- paste(invg,sep="", collapse = "")
u <- unique(strsplit(collapsed,"")[[1]])
if(length(u) < 2){
return( invg)
}
u <- u[order(u)]
m <- matrix(nrow = NROW(invg), ncol=length(u))
m[]<-F
for(i in 1:length( invg)){
s <- strsplit( invg[i],"")[[1]]
index <- match(s, u)
m[i,index] <- T
}
for(i in 1:(length(u) - 1)){
firstColT <- match(T, m[,i])[1]
firstT <- match(T, rowSums(m[,i:length(u)] > 0))[1]
if(firstT < firstColT){
colT <- match(T,m[firstT,i:length(u)])[1]
colT <- colT + i - 1
tmp <- m[, colT]
m[,colT] <- m[,i]
m[,i] <- tmp
}
}
res <- vector(mode = "character", length=length("trt"))
for(i in 1:length(invg)){
l <- u[m[i,]]
res[i] <- paste(l, sep="",collapse = "")
}
return(res)
}
# Preparing final result table including letter grouping of the means:
g <- LSD.test(lm, "T", group=T, console = T, alpha = 0.05, p.adj = "none")$groups
g <- g[rev(rownames(g)),] #order the result the way you want
g$groups <- invOrder(as.character(g$groups))
g$groups
g$groups <- invOrder(as.character(g$groups))
mean <- LSD.test(lm, "T", group=T, console = T, alpha = 0.05, p.adj = "none")$means
mean$RowNames <- rownames(mean)
mean <- separate(mean, RowNames, into = c("Cultivar", "Drought", "Bacteria"), sep = "_", remove = T)
mean <- mean[order(rownames(mean)),]
g <- g[order(rownames(g)),]
fc <- data.frame(mean[,(ncol(mean)-2):ncol(mean)], wDCt = 10^(-mean[1]),
LCL = 10^(-mean[5]), UCL = 10^(-mean[4]), letters = g[,2],
std = mean$std, r = mean$r)
fc
# Input weighted delta Ct (wDCt) data (wDCt = log10(2)*CtTARGET  -  log10(2)*CtREF) (Ganger et al., 2017)
df0 <- read.table(text = "
Cultivar	Drought	Bacteria	Rep	E_TDC	TDC_Ct	E_IF4	IF4_Ct
Resistant	Control	Ctrl	1	2	33.3	2	31.52666667
Resistant	Control	Ctrl	2	2	33.39	2	31.57
Resistant	Control	Ctrl	3	2	33.345	2	31.54833333
Resistant	Control	Inoculate	1	2	34.00666667	2	31.48333333
Resistant	Control	Inoculate	2	2	36.82	2	31.44333333
Resistant	Control	Inoculate	3	2	35.41333333	2	31.46333333
Resistant	Moderate	Ctrl	1	2	32.72333333	2	31.30333333
Resistant	Moderate	Ctrl	2	2	32.45333333	2	32.5
Resistant	Moderate	Ctrl	3	2	32.58833333	2	31.90166667
Resistant	Moderate	Inoculate	1	2	33.30333333	2	31.19666667
Resistant	Moderate	Inoculate	2	2	33.11666667	2	31.94333333
Resistant	Moderate	Inoculate	3	2	33.21	2	31.57
Resistant	High	Ctrl	1	2	33.40333333	2	33.37
Resistant	High	Ctrl	2	2	33.25333333	2	33.37
Resistant	High	Ctrl	3	2	33.32833333	2	33.37
Resistant	High	Inoculate	1	2	32.50666667	2	33.47
Resistant	High	Inoculate	2	2	32.62333333	2	33.26
Resistant	High	Inoculate	3	2	32.565	2	33.365
Resistant	Control	Ctrl	1	2	26.89333333	2	26.91666667
Sensetive	Control	Ctrl	2	2	28.175	2	27.69
Sensetive	Control	Ctrl	3	2	27.98666667	2	27.30333333
Sensetive	Control	Inoculate	1	2	28.715	2	29.45
Sensetive	Control	Inoculate	2	2	29.01	2	29.43333333
Sensetive	Control	Inoculate	3	2	28.81333333	2	29.44166667
Sensetive	Moderate	Ctrl	1	2	30.41	2	28.73333333
Sensetive	Moderate	Ctrl	2	2	29.49666667	2	28.67333333
Sensetive	Moderate	Ctrl	3	2	29.95333333	2	28.70333333
Sensetive	Moderate	Inoculate	1	2	28.91	2	28.09666667
Sensetive	Moderate	Inoculate	2	2	28.605	2	28.64666667
Sensetive	Moderate	Inoculate	3	2	28.59	2	28.37166667
Sensetive	High	Ctrl	1	2	29.035	2	30.60333333
Sensetive	High	Ctrl	2	2	28.73	2	30.2
Sensetive	High	Ctrl	3	2	28.83166667	2	30.40166667
Sensetive	High	Inoculate	1	2	28.29666667	2	30.84
Sensetive	High	Inoculate	2	2	28.53	2	30.65
Sensetive	High	Inoculate	3	2	28.285	2	30.745
", header = T)
colnames(df)[1] <- "A"
colnames(df)[2] <- "B"
colnames(df)[3] <- "C"
colnames(df)[4] <- "rep"
colnames(df)[5] <- "Etarget"
colnames(df)[6] <- "Cttarget"
colnames(df)[7] <- "Eref"
colnames(df)[8] <- "Ctref"
df$wDCt <- (log10(df$Etarget)*df$Cttarget)-(log10(df$Eref)*df$Ctref)
# If ANOVA based on factorial design was desired:
factorialANOVA <- anova(lm0 <- lm(wDCt ~  A*B*C, df))
factorialANOVA
# If ANOVA based on completly randomized design was required: This is especially useful when you wand to do mean grouping.
df <- data.frame(df, T = paste0(df[,1],"_",df[,2],"_",df[,3]))
lm <- lm(wDCt ~ T, df)
anovaCRD <- anova(lm)
anovaCRD
#Checking normality of residuals produced by the lm object.
shapiro.test(lm$residuals)
invOrder <-function(invg){
collapsed <- paste(invg,sep="", collapse = "")
u <- unique(strsplit(collapsed,"")[[1]])
if(length(u) < 2){
return( invg)
}
u <- u[order(u)]
m <- matrix(nrow = NROW(invg), ncol=length(u))
m[]<-F
for(i in 1:length( invg)){
s <- strsplit( invg[i],"")[[1]]
index <- match(s, u)
m[i,index] <- T
}
for(i in 1:(length(u) - 1)){
firstColT <- match(T, m[,i])[1]
firstT <- match(T, rowSums(m[,i:length(u)] > 0))[1]
if(firstT < firstColT){
colT <- match(T,m[firstT,i:length(u)])[1]
colT <- colT + i - 1
tmp <- m[, colT]
m[,colT] <- m[,i]
m[,i] <- tmp
}
}
res <- vector(mode = "character", length=length("trt"))
for(i in 1:length(invg)){
l <- u[m[i,]]
res[i] <- paste(l, sep="",collapse = "")
}
return(res)
}
# Preparing final result table including letter grouping of the means:
g <- LSD.test(lm, "T", group=T, console = T, alpha = 0.05, p.adj = "none")$groups
g <- g[rev(rownames(g)),] #order the result the way you want
g$groups <- invOrder(as.character(g$groups))
mean <- LSD.test(lm, "T", group=T, console = T, alpha = 0.05, p.adj = "none")$means
mean$RowNames <- rownames(mean)
mean <- separate(mean, RowNames, into = c("Cultivar", "Drought", "Bacteria"), sep = "_", remove = T)
mean <- mean[order(rownames(mean)),]
g <- g[order(rownames(g)),]
fc <- data.frame(mean[,(ncol(mean)-2):ncol(mean)], wDCt = 10^(-mean[1]),
LCL = 10^(-mean[5]), UCL = 10^(-mean[4]), letters = g[,2],
std = 10^(mean$std), r = mean$r)
fc
# Input weighted delta Ct (wDCt) data (wDCt = log10(2)*CtTARGET  -  log10(2)*CtREF) (Ganger et al., 2017)
df0 <- read.table(text = "
Cultivar	Drought	Bacteria	Rep	E_TDC	TDC_Ct	E_IF4	IF4_Ct
Resistant	Control	Ctrl	1	2	33.3	2	31.52666667
Resistant	Control	Ctrl	2	2	33.39	2	31.57
Resistant	Control	Ctrl	3	2	33.345	2	31.54833333
Resistant	Control	Inoculate	1	2	34.00666667	2	31.48333333
Resistant	Control	Inoculate	2	2	36.82	2	31.44333333
Resistant	Control	Inoculate	3	2	35.41333333	2	31.46333333
Resistant	Moderate	Ctrl	1	2	32.72333333	2	31.30333333
Resistant	Moderate	Ctrl	2	2	32.45333333	2	32.5
Resistant	Moderate	Ctrl	3	2	32.58833333	2	31.90166667
Resistant	Moderate	Inoculate	1	2	33.30333333	2	31.19666667
Resistant	Moderate	Inoculate	2	2	33.11666667	2	31.94333333
Resistant	Moderate	Inoculate	3	2	33.21	2	31.57
Resistant	High	Ctrl	1	2	33.40333333	2	33.37
Resistant	High	Ctrl	2	2	33.25333333	2	33.37
Resistant	High	Ctrl	3	2	33.32833333	2	33.37
Resistant	High	Inoculate	1	2	32.50666667	2	33.47
Resistant	High	Inoculate	2	2	32.62333333	2	33.26
Resistant	High	Inoculate	3	2	32.565	2	33.365
Resistant	Control	Ctrl	1	2	26.89333333	2	26.91666667
Sensetive	Control	Ctrl	2	2	28.175	2	27.69
Sensetive	Control	Ctrl	3	2	27.98666667	2	27.30333333
Sensetive	Control	Inoculate	1	2	28.715	2	29.45
Sensetive	Control	Inoculate	2	2	29.01	2	29.43333333
Sensetive	Control	Inoculate	3	2	28.81333333	2	29.44166667
Sensetive	Moderate	Ctrl	1	2	30.41	2	28.73333333
Sensetive	Moderate	Ctrl	2	2	29.49666667	2	28.67333333
Sensetive	Moderate	Ctrl	3	2	29.95333333	2	28.70333333
Sensetive	Moderate	Inoculate	1	2	28.91	2	28.09666667
Sensetive	Moderate	Inoculate	2	2	28.605	2	28.64666667
Sensetive	Moderate	Inoculate	3	2	28.59	2	28.37166667
Sensetive	High	Ctrl	1	2	29.035	2	30.60333333
Sensetive	High	Ctrl	2	2	28.73	2	30.2
Sensetive	High	Ctrl	3	2	28.83166667	2	30.40166667
Sensetive	High	Inoculate	1	2	28.29666667	2	30.84
Sensetive	High	Inoculate	2	2	28.53	2	30.65
Sensetive	High	Inoculate	3	2	28.285	2	30.745
", header = T)
colnames(df)[1] <- "A"
colnames(df)[2] <- "B"
colnames(df)[3] <- "C"
colnames(df)[4] <- "rep"
colnames(df)[5] <- "Etarget"
colnames(df)[6] <- "Cttarget"
colnames(df)[7] <- "Eref"
colnames(df)[8] <- "Ctref"
df$wDCt <- (log10(df$Etarget)*df$Cttarget)-(log10(df$Eref)*df$Ctref)
# If ANOVA based on factorial design was desired:
factorialANOVA <- anova(lm0 <- lm(wDCt ~  A*B*C, df))
factorialANOVA
# If ANOVA based on completly randomized design was required: This is especially useful when you wand to do mean grouping.
df <- data.frame(df, T = paste0(df[,1],"_",df[,2],"_",df[,3]))
lm <- lm(wDCt ~ T, df)
anovaCRD <- anova(lm)
anovaCRD
#Checking normality of residuals produced by the lm object.
shapiro.test(lm$residuals)
invOrder <-function(invg){
collapsed <- paste(invg,sep="", collapse = "")
u <- unique(strsplit(collapsed,"")[[1]])
if(length(u) < 2){
return( invg)
}
u <- u[order(u)]
m <- matrix(nrow = NROW(invg), ncol=length(u))
m[]<-F
for(i in 1:length( invg)){
s <- strsplit( invg[i],"")[[1]]
index <- match(s, u)
m[i,index] <- T
}
for(i in 1:(length(u) - 1)){
firstColT <- match(T, m[,i])[1]
firstT <- match(T, rowSums(m[,i:length(u)] > 0))[1]
if(firstT < firstColT){
colT <- match(T,m[firstT,i:length(u)])[1]
colT <- colT + i - 1
tmp <- m[, colT]
m[,colT] <- m[,i]
m[,i] <- tmp
}
}
res <- vector(mode = "character", length=length("trt"))
for(i in 1:length(invg)){
l <- u[m[i,]]
res[i] <- paste(l, sep="",collapse = "")
}
return(res)
}
# Preparing final result table including letter grouping of the means:
g <- LSD.test(lm, "T", group=T, console = T, alpha = 0.05, p.adj = "none")$groups
g <- g[rev(rownames(g)),] #order the result the way you want
g$groups <- invOrder(as.character(g$groups))
mean <- LSD.test(lm, "T", group=T, console = T, alpha = 0.05, p.adj = "none")$means
mean$RowNames <- rownames(mean)
mean <- separate(mean, RowNames, into = c("Cultivar", "Drought", "Bacteria"), sep = "_", remove = T)
mean <- mean[order(rownames(mean)),]
g <- g[order(rownames(g)),]
fc <- data.frame(mean[,(ncol(mean)-2):ncol(mean)], wDCt = 10^(-mean[1]),
LCL = 10^(-mean[5]), UCL = 10^(-mean[4]), letters = g[,2],
std = 10^(-mean$std), r = mean$r)
fc
# Barplot with the standard deviations as error bars:
ggplot(fc, aes(factor(x = Drought, levels = c( "Control","Moderate", "High")),
y = wDCt, group = interaction(Cultivar, Bacteria), fill = Cultivar)) +
geom_col(color= "black", position = "dodge", width = 0.5) +
scale_fill_manual(values = c("#C6E2FF", "#F0FFF0"))+
geom_hline(aes(yintercept = 1, col = "red"),linetype=2, show.legend = FALSE) +
geom_errorbar(aes(ymin=wDCt, ymax=wDCt+std), width=0.2, position =position_dodge(width = 0.5)) +
geom_text(aes(label=letters, x=Drought, y=wDCt+std), vjust=-0.5, size=4, position =position_dodge(width = 0.5))+
ylab("Relative Expression") + theme_bw()+
xlab("Drought Stress") +
theme(axis.text.x = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.text.y = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.title  = element_text(size=12)) +
scale_y_continuous(breaks=seq(0,6,by =2),limits = c(0,6), expand = c(0,0))+
theme(legend.position = c(0.09, 0.8), legend.text = element_text(colour="black", size=12),
legend.background = element_rect(fill="transparent"))+
facet_wrap(~Bacteria, nrow = 1)
# Barplot with the standard deviations as error bars:
ggplot(fc, aes(factor(x = Drought, levels = c( "Control","Moderate", "High")),
y = wDCt, group = interaction(Cultivar, Bacteria), fill = Cultivar)) +
geom_col(color= "black", position = "dodge", width = 0.5) +
scale_fill_manual(values = c("#C6E2FF", "#F0FFF0"))+
geom_hline(aes(yintercept = 1, col = "red"),linetype=2, show.legend = FALSE) +
geom_errorbar(aes(ymin=wDCt, ymax=wDCt+std), width=0.2, position =position_dodge(width = 0.5)) +
geom_text(aes(label=letters, x=Drought, y=wDCt+std), vjust=-0.5, size=4, position =position_dodge(width = 0.5))+
ylab("Relative Expression") + theme_bw()+
xlab("Drought Stress") +
theme(axis.text.x = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.text.y = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.title  = element_text(size=12)) +
scale_y_continuous(breaks=seq(0,8,by =2),limits = c(0,8), expand = c(0,0))+
theme(legend.position = c(0.09, 0.8), legend.text = element_text(colour="black", size=12),
legend.background = element_rect(fill="transparent"))+
facet_wrap(~Bacteria, nrow = 1)
g
mean
fc
# Barplot with the standard deviations as error bars:
ggplot(fc, aes(factor(x = Drought, levels = c( "Control","Moderate", "High")),
y = wDCt, group = interaction(Cultivar, Bacteria), fill = Cultivar)) +
geom_col(color= "black", position = "dodge", width = 0.5) +
scale_fill_manual(values = c("#C6E2FF", "#F0FFF0"))+
geom_hline(aes(yintercept = 1, col = "red"),linetype=2, show.legend = FALSE) +
geom_errorbar(aes(ymin=wDCt, ymax=wDCt+std), width=0.2, position =position_dodge(width = 0.5)) +
geom_text(aes(label=letters, x=Drought, y=wDCt+std), vjust=-0.5, size=4, position =position_dodge(width = 0.5))+
ylab("Relative Expression") + theme_bw()+
xlab("Drought Stress") +
theme(axis.text.x = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.text.y = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.title  = element_text(size=12)) +
scale_y_continuous(breaks=seq(0,7,by =2),limits = c(0,7), expand = c(0,0))+
theme(legend.position = c(0.09, 0.8), legend.text = element_text(colour="black", size=12),
legend.background = element_rect(fill="transparent"))+
facet_wrap(~Bacteria, nrow = 1)
# Barplot with the 95% confidence interval as error bar:
ggplot(fc, aes(factor(x = Drought, levels = c( "Control","Moderate", "High")),
y = wDCt, group = interaction(Cultivar, Bacteria), fill = Cultivar)) +
geom_col(color= "black", position = "dodge", width = 0.5) +
scale_fill_manual(values = c("#C6E2FF", "#F0FFF0"))+
geom_hline(aes(yintercept = 1, col = "red"),linetype=2, show.legend = FALSE) +
geom_errorbar(aes(ymin=LCL, ymax=UCL), width=0.2, position =position_dodge(width = 0.5)) +
geom_text(aes(label=letters, x=Drought, y=LCL), vjust=-0.5, size=4, position =position_dodge(width = 0.5))+
ylab("Relative Expression") + theme_bw()+
xlab("Drought Stress") +
theme(axis.text.x = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.text.y = element_text(size=12, color = "black", angle = 0, hjust = 0.5),
axis.title  = element_text(size=12)) +
scale_y_continuous(breaks=seq(0,9.5,by =2),limits = c(0,9.5), expand = c(0,0))+
theme(legend.position = c(0.09, 0.8), legend.text = element_text(colour="black", size=12),
legend.background = element_rect(fill="transparent"))+
facet_wrap(~Bacteria, nrow = 1)
install.packages("E:/Dropbox/iqpcr/iqpcr_1.0.0.tar.gz", repos = NULL, type = "source")
library(iqpcr)
res <- qpcrANOVA(data_3factor_b)$Result
qpcrANOVA(data_3factor_b)$Result
qpcrANOVA(data_3factor_b)
library(devtools)
use_data(data_3factor_a, overwrite = T)
setwd("E:/Dropbox/iqpcr/iqpcr/R")
use_data(data_3factor_a, overwrite = T)
use_data(data_3factor_b, overwrite = T)
document()
document()
build()
use_data(data_3factor_b, overwrite = T)
document()
build()
remove.packages("iqpcr")
install.packages("E:/Dropbox/iqpcr/iqpcr_1.0.0.tar.gz", repos = NULL, type = "source")
library(iqpcr)
library(devtools)
library(devtools)
use_data(data_3factor_a, overwrite = T)
check()
document()
use_data(data_2factor, overwrite = T)
use_data(data_3factor_b, overwrite = T)
use_data(data_3factor_a, overwrite = T)
use_data(data_2factor, overwrite = T)
document()
check()
build()
remove.packages("iqpcr")
install.packages("E:/Dropbox/iqpcr/iqpcr_1.0.0.tar.gz", repos = NULL, type = "source")
library(iqpcr)
res <- qpcrANOVA(data_3factor_b)$Result
threeFACTORplot(
x,
arrangement = c(1, 2, 3),
bar.width = 0.5,
fill = "Reds",
xlab = "Gene",
ylab = "Relative Expression",
errorbar = "std",
y.axis.adjust = 0.5,
y.axis.by = 2,
letter.position.adjust = 0.3,
legend.title = "Legend Title",
legend.position = c(0.4, 0.8),
fontsize = 12,
show.letters = F
)
threeFACTORplot(
res,
arrangement = c(1, 2, 3),
bar.width = 0.5,
fill = "Reds",
xlab = "Gene",
ylab = "Relative Expression",
errorbar = "std",
y.axis.adjust = 0.5,
y.axis.by = 2,
letter.position.adjust = 0.3,
legend.title = "Legend Title",
legend.position = c(0.4, 0.8),
fontsize = 12,
show.letters = F
)
threeFACTORplot(
res,
arrangement = c(1, 2, 3),
bar.width = 0.5,
fill = "Reds",
xlab = "Gene",
ylab = "Relative Expression",
errorbar = "std",
y.axis.adjust = 0.5,
y.axis.by = 2,
letter.position.adjust = 0.3,
legend.title = "Legend Title",
legend.position = c(0.4, 0.8),
fontsize = 12,
show.letters = T
)
threeFACTORplot(
res,
arrangement = c(1, 2, 3),
bar.width = 0.5,
fill = "Reds",
xlab = "Gene",
ylab = "Relative Expression",
errorbar = "std",
y.axis.adjust = 0.5,
y.axis.by = 2,
letter.position.adjust = 0.3,
legend.title = "Drought",
legend.position = c(0.4, 0.8),
fontsize = 12,
show.letters = T
)
data_withTechRep
library(devtools)
setwd("E:/Dropbox/iqpcr")
submit_cran("iqpcr")
citation("iqpcr")
setwd(./iqpcr/R)
setwd(/iqpcr/R)
setwd(../iqpcr/R)
setwd("../iqpcr/R")
setwd('../iqpcr/R')
setwd('..')
setwd('../iqpcr')
setwd('E:/Dropbox/iqpcr/iqpcr/R')
use_data(data_ttest, overwrite = T)
document()
library(iqpcr)
remove.packages("iqpcr")
document()
check()
use_data(data_ttest, overwrite = T)
library(devtools)
use_data(data_ttest, overwrite = T)
document()
check()
document()
check()
build()
install.packages("E:/Dropbox/iqpcr/iqpcr_1.0.0.tar.gz", repos = NULL, type = "source")
library(iqpcr)
x <- qpcrTTEST(x, paired = FALSE, var.equal = FALSE)
x <- qpcrTTEST(data_ttest, paired = FALSE, var.equal = FALSE)
x$Raw_data
x$Result
iqpcr::vignette
library(devtools)
?use_readme_md
use_readme_md()
detach("package:iqpcr", unload = TRUE)
remove.packages("iqpcr")
devtools::install_github('mirzaghaderi/iqpcr')
devtools::install_github('https://github.com/mirzaghaderi/iqpcr.git')
devtools::install_github('mirzaghaderi/iqpcr')
devtools::install_github('MahShaaban/pcr')
devtools::install_github('MahShaaban/pcr')
devtools::install_github("https://github.com/mirzaghaderi/iqpcr.git")
